{
    "docs": [
        {
            "location": "/", 
            "text": "Latte.jl\n\n\nLatte is a high-performance DSL for deep neural networks.  Our goal was to design a language that closely matched domain concepts without sacrificing performance.\n\n\nIf you use Latte for research, please use the following citation:\n\n\nForthcoming...", 
            "title": "Home"
        }, 
        {
            "location": "/#lattejl", 
            "text": "Latte is a high-performance DSL for deep neural networks.  Our goal was to design a language that closely matched domain concepts without sacrificing performance.  If you use Latte for research, please use the following citation:  Forthcoming...", 
            "title": "Latte.jl"
        }, 
        {
            "location": "/man/setup/", 
            "text": "Setup\n\n\n\n\nPrerequisites\n\n\nTo build Latte, you will need HDF5 and cmake.  What to install will vary by platform and your needs.  On Ubuntu, try:\n\n\n$ sudo apt-get install hdf5-tools libhdf5-dev cmake\n\n\n\n\n\nLatte currently depends on \nIntel MKL\n and the \nIntel C++ Compiler (icpc)\n.\n\n\n\n\nQuick Install\n\n\n# Latte currently depends on the master branch of these packages\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/IntelLabs/Latte.jl\n)\n\n\njulia\n \nPkg\n.\ncheckout\n(\nCompilerTools\n)\n\n\njulia\n \nPkg\n.\ncheckout\n(\nParallelAccelerator\n)\n\n\njulia\n \n# To build with MPI enabled, uncomment these lines\n\n\njulia\n \n# ENV[\nLATTE_BUILD_MPI\n] = 1\n\n\njulia\n \n# ENV[\nCXX\n] = \nmpiicpc\n  # Replace with your mpi compiler wrapper\n\n\njulia\n \nPkg\n.\nbuild\n(\nLatte\n)", 
            "title": "Setup"
        }, 
        {
            "location": "/man/setup/#setup", 
            "text": "", 
            "title": "Setup"
        }, 
        {
            "location": "/man/setup/#prerequisites", 
            "text": "To build Latte, you will need HDF5 and cmake.  What to install will vary by platform and your needs.  On Ubuntu, try:  $ sudo apt-get install hdf5-tools libhdf5-dev cmake  Latte currently depends on  Intel MKL  and the  Intel C++ Compiler (icpc) .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/man/setup/#quick-install", 
            "text": "# Latte currently depends on the master branch of these packages  julia   Pkg . clone ( https://github.com/IntelLabs/Latte.jl )  julia   Pkg . checkout ( CompilerTools )  julia   Pkg . checkout ( ParallelAccelerator )  julia   # To build with MPI enabled, uncomment these lines  julia   # ENV[ LATTE_BUILD_MPI ] = 1  julia   # ENV[ CXX ] =  mpiicpc   # Replace with your mpi compiler wrapper  julia   Pkg . build ( Latte )", 
            "title": "Quick Install"
        }, 
        {
            "location": "/man/examples/", 
            "text": "Examples\n\n\n\n\nMNIST\n\n\n$ \ncd\n ~/.julia/v0.4/Latte/examples/mnist/data\n$ ./get-data.sh\n$ \ncd\n ..\n$ julia mnist.jl\n\n\n\n\n\n\n\ncifar10\n\n\n$ \ncd\n ~/.julia/v0.4/Latte/examples/cifar10/data\n$ ./get-data.sh\n$ \ncd\n ..\n$ julia vgg-mini.jl", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#mnist", 
            "text": "$  cd  ~/.julia/v0.4/Latte/examples/mnist/data\n$ ./get-data.sh\n$  cd  ..\n$ julia mnist.jl", 
            "title": "MNIST"
        }, 
        {
            "location": "/man/examples/#cifar10", 
            "text": "$  cd  ~/.julia/v0.4/Latte/examples/cifar10/data\n$ ./get-data.sh\n$  cd  ..\n$ julia vgg-mini.jl", 
            "title": "cifar10"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public\n\n\n\n\nContents\n\n\n\n\nPublic\n\n\nContents\n\n\nIndex\n\n\nAPI\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nLatte.Connection\n\n\nLatte.Ensemble\n\n\nLatte.Net\n\n\nLatte.Net\n\n\nLatte.Param\n\n\nLatte.add_connections\n\n\nLatte.add_ensemble\n\n\nLatte.get_buffer\n\n\nLatte.init\n\n\nLatte.load_snapshot\n\n\nLatte.save_snapshot\n\n\nLatte.test\n\n\n\n\n\n\nAPI\n\n\n#\n\n\nLatte.Net\n \n \nType\n.\n\n\n\n\n Fields \n\n\n\n\nensembles\n          \u2013 a vector containing each \nEnsemble\n in the network.\n\n\nensembles_map\n      \u2013 a mapping between ensemble names in the network to the                           instance stored in \nensembles\n\n\nbuffers\n            \u2013 the internal buffers used by the network\n\n\ncurr_buffer_set\n    \u2013 the current buffer set (used for double buffering)\n\n\nforward_tasks\n      \u2013 a set of tasks for performing forward propogation of the network\n\n\nbackward_tasks\n     \u2013 a set of tasks for performing back propogation of the network\n\n\nupdate_tasks\n       \u2013 a set of tasks for performing parameter updates\n\n\nparams\n             \u2013 a vector of \nParam\n instances corresponding to network parameters\n\n\nrun_where\n          \u2013 DEPRECATED\n\n\nsignal\n             \u2013 DEPRECATED\n\n\nbatch_size\n         \u2013 the batch size of the network                            TODO: support different batch sizes for train/test\n\n\ntrain_epoch\n        \u2013 number of epochs completed for training\n\n\ntest_epoch\n         \u2013 number of epochs completed for testing\n\n\ncurr_time_step\n     \u2013 the current time step (for RNNs)\n\n\ntime_steps\n         \u2013 total number of time steps to unroll (for RNNs)\n\n\nnum_subgroups\n      \u2013 number of partitions in network (for model parallelism)\n\n\nensemble_send_list\n \u2013 a mapping between ensembles and a list of subgroups to send                           values to, used internally when synthesizing code for                           model parallelism\n\n\n\n\n#\n\n\nLatte.Net\n \n \nMethod\n.\n\n\n\n\nMain \nNet\n constructor that should be used. \n Params \n - \nbatch_size\n    \u2013 batch size of the network - \ntime_steps\n    \u2013 number of time steps to unroll the network (for RNNs) - \nnum_subgroups\n \u2013 number of subgroups in the network (for model parallelism)\n\n\n#\n\n\nLatte.Ensemble\n \n \nType\n.\n\n\n\n\nAn ensemble\n\n\n Fields \n\n\n\n\nname         \u2013 name of the ensemble\n\n\nneurons      \u2013 an array of neurons of type \nT\n\n\nconnections  \u2013 a list of \nEnsemble\ns connected to this ensemble\n\n\nbatch_fields \u2013 a vector of \nBatch\n fields for \nT\n (used internally)\n\n\narg_dim_info \u2013 \n\n\nparams       \u2013 a vector of \nParam\ns associated with the ensemble\n\n\nphase        \u2013 phase(s) in which this ensemble is active\n\n\nnet_subgroup \u2013 the net subgroup the ensemble is a member of (use for model parallelism)\n\n\n\n\n#\n\n\nLatte.Connection\n \n \nType\n.\n\n\n\n\nA connection between two ensembles.\n\n\n Fields \n\n\n\n\nsource        \u2013 the source \nEnsemble\n\n\nmapping       \u2013 a mapping function to a range of neurons in \nsource\n\n\nshape         \u2013 shape of the connected neurons returned by \nmapping\n\n\nsize          \u2013 length of the connected neurons returned by \nmapping\n\n\ncopy          \u2013 whether the connection requires input values to be copied\n\n\nis_dim_fixed  \u2013 vector of booleans that are true if the connection is fixed along a dimension\n\n\nis_one_to_one \u2013 whether the connection is one to one\n\n\npadding       \u2013 amount of padding used for the connection\n\n\nrecurrent     \u2013 whether the connection is recurrent\n\n\n\n\n#\n\n\nLatte.Param\n \n \nType\n.\n\n\n\n\nA parameter in a \nNet\n (learned during training)\n\n\n Fields \n\n\n\n\nname\n          \u2013 the name of the parameter\n\n\ngradient_name\n \u2013 the name of the gradient (should be \u2207\nname\n)\n\n\nhist_name\n     \u2013 the name of the history buffer (should be \nname\nhist)\n\n\nlearning_rate   \u2013 local learning rate for the parameter\n\n\nregu_coef       \u2013 local regularization coefficient\n\n\nclip_gradients  \u2013 NOT IMPLEMENTED, gradient clipping parameter\n\n\nvalue           \u2013 buffer containing the value of the parameter\n\n\ngradient        \u2013 buffer containing the gradient of the parameter\n\n\nhist            \u2013 buffer containing the history of the parameter\n\n\nrequest         \u2013 request id, used for MPI data parallelism\n\n\n\n\n#\n\n\nLatte.get_buffer\n \n \nMethod\n.\n\n\n\n\nGet a buffer at the time_step \nt\n\n\n Params \n\n\n\n\nnet\n   \u2013 network to get buffer\n\n\nname\n  \u2013 name of the buffer\n\n\nt\n     \u2013 time step\n\n\n\n\n#\n\n\nLatte.add_connections\n \n \nMethod\n.\n\n\n\n\nConnect neurons in \nsource\n to neurons in \nsink\n using the function \nmapping\n. \nmapping\n should be a function with a parameter for the index in each dimension of sink. For example, if sink is a 3-d ensemble, mapping = f(i, j, k) -\n ...\n\n\nmapping\n should return a tuple of continuous ranges corresponding to the indices of neurons in source that should be connected to the neuron at the current index\n\n\n#\n\n\nLatte.add_ensemble\n \n \nMethod\n.\n\n\n\n\nAdd an ensemble to the network \nnet\n\n\n#\n\n\nLatte.init\n \n \nMethod\n.\n\n\n\n\nInitialize the network \nnet\n\n\n#\n\n\nLatte.load_snapshot\n \n \nMethod\n.\n\n\n\n\nLoad a network snapshot from \nfile\n.\n\n\nTODO: Can we save the structure of \nnet\n in the snapshot?\n\n\n#\n\n\nLatte.save_snapshot\n \n \nMethod\n.\n\n\n\n\nSave a snapshot of \nnet\n to \nfile\n\n\n#\n\n\nLatte.test\n \n \nMethod\n.\n\n\n\n\nTest \nnet\n for one epoch", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public", 
            "text": "", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public  Contents  Index  API", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "Latte.Connection  Latte.Ensemble  Latte.Net  Latte.Net  Latte.Param  Latte.add_connections  Latte.add_ensemble  Latte.get_buffer  Latte.init  Latte.load_snapshot  Latte.save_snapshot  Latte.test", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#api", 
            "text": "#  Latte.Net     Type .    Fields    ensembles           \u2013 a vector containing each  Ensemble  in the network.  ensembles_map       \u2013 a mapping between ensemble names in the network to the                           instance stored in  ensembles  buffers             \u2013 the internal buffers used by the network  curr_buffer_set     \u2013 the current buffer set (used for double buffering)  forward_tasks       \u2013 a set of tasks for performing forward propogation of the network  backward_tasks      \u2013 a set of tasks for performing back propogation of the network  update_tasks        \u2013 a set of tasks for performing parameter updates  params              \u2013 a vector of  Param  instances corresponding to network parameters  run_where           \u2013 DEPRECATED  signal              \u2013 DEPRECATED  batch_size          \u2013 the batch size of the network                            TODO: support different batch sizes for train/test  train_epoch         \u2013 number of epochs completed for training  test_epoch          \u2013 number of epochs completed for testing  curr_time_step      \u2013 the current time step (for RNNs)  time_steps          \u2013 total number of time steps to unroll (for RNNs)  num_subgroups       \u2013 number of partitions in network (for model parallelism)  ensemble_send_list  \u2013 a mapping between ensembles and a list of subgroups to send                           values to, used internally when synthesizing code for                           model parallelism   #  Latte.Net     Method .   Main  Net  constructor that should be used.   Params   -  batch_size     \u2013 batch size of the network -  time_steps     \u2013 number of time steps to unroll the network (for RNNs) -  num_subgroups  \u2013 number of subgroups in the network (for model parallelism)  #  Latte.Ensemble     Type .   An ensemble   Fields    name         \u2013 name of the ensemble  neurons      \u2013 an array of neurons of type  T  connections  \u2013 a list of  Ensemble s connected to this ensemble  batch_fields \u2013 a vector of  Batch  fields for  T  (used internally)  arg_dim_info \u2013   params       \u2013 a vector of  Param s associated with the ensemble  phase        \u2013 phase(s) in which this ensemble is active  net_subgroup \u2013 the net subgroup the ensemble is a member of (use for model parallelism)   #  Latte.Connection     Type .   A connection between two ensembles.   Fields    source        \u2013 the source  Ensemble  mapping       \u2013 a mapping function to a range of neurons in  source  shape         \u2013 shape of the connected neurons returned by  mapping  size          \u2013 length of the connected neurons returned by  mapping  copy          \u2013 whether the connection requires input values to be copied  is_dim_fixed  \u2013 vector of booleans that are true if the connection is fixed along a dimension  is_one_to_one \u2013 whether the connection is one to one  padding       \u2013 amount of padding used for the connection  recurrent     \u2013 whether the connection is recurrent   #  Latte.Param     Type .   A parameter in a  Net  (learned during training)   Fields    name           \u2013 the name of the parameter  gradient_name  \u2013 the name of the gradient (should be \u2207 name )  hist_name      \u2013 the name of the history buffer (should be  name hist)  learning_rate   \u2013 local learning rate for the parameter  regu_coef       \u2013 local regularization coefficient  clip_gradients  \u2013 NOT IMPLEMENTED, gradient clipping parameter  value           \u2013 buffer containing the value of the parameter  gradient        \u2013 buffer containing the gradient of the parameter  hist            \u2013 buffer containing the history of the parameter  request         \u2013 request id, used for MPI data parallelism   #  Latte.get_buffer     Method .   Get a buffer at the time_step  t   Params    net    \u2013 network to get buffer  name   \u2013 name of the buffer  t      \u2013 time step   #  Latte.add_connections     Method .   Connect neurons in  source  to neurons in  sink  using the function  mapping .  mapping  should be a function with a parameter for the index in each dimension of sink. For example, if sink is a 3-d ensemble, mapping = f(i, j, k) -  ...  mapping  should return a tuple of continuous ranges corresponding to the indices of neurons in source that should be connected to the neuron at the current index  #  Latte.add_ensemble     Method .   Add an ensemble to the network  net  #  Latte.init     Method .   Initialize the network  net  #  Latte.load_snapshot     Method .   Load a network snapshot from  file .  TODO: Can we save the structure of  net  in the snapshot?  #  Latte.save_snapshot     Method .   Save a snapshot of  net  to  file  #  Latte.test     Method .   Test  net  for one epoch", 
            "title": "API"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internals\n\n\n\n\nContents\n\n\n\n\nInternals\n\n\nContents\n\n\nIndex\n\n\nNet\n\n\nConnections\n\n\nSynthesis and Optimization\n\n\nUtility Datastructures\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nLatte.Batch\n\n\nLatte.JuliaTask\n\n\nLatte.TaskSet\n\n\nLatte.UpdateTask\n\n\nLatte.add_forward_data_tasks\n\n\nLatte.add_forward_julia_tasks\n\n\nLatte.add_recv_expr\n\n\nLatte.add_send_exprs\n\n\nLatte.check_dimensions_fixed\n\n\nLatte.check_one_to_one\n\n\nLatte.clear_values\n\n\nLatte.clear_\u2207\n\n\nLatte.gen_copy_block\n\n\nLatte.gen_neuron_backward\n\n\nLatte.gen_neuron_forward\n\n\nLatte.generate_c_function\n\n\nLatte.get_buffer\n\n\nLatte.get_inner_loop_tiler\n\n\nLatte.get_src_idx\n\n\nLatte.get_tile_fusion_factor_backward\n\n\nLatte.get_tile_fusion_factor_forward\n\n\nLatte.get_tile_loops\n\n\nLatte.init_backward\n\n\nLatte.init_backward\n\n\nLatte.init_backward\n\n\nLatte.init_buffer\n\n\nLatte.init_forward\n\n\nLatte.init_forward\n\n\nLatte.init_forward\n\n\nLatte.inner_loop_tiler\n\n\nLatte.is_tiled_loop\n\n\nLatte.optimize\n\n\nLatte.push_compute_tasks!\n\n\nLatte.rand_values\n\n\nLatte.set_buffer\n\n\nLatte.set_buffer\n\n\nLatte.tile_size_inliner\n\n\nLatte.unpack_tiled_loop\n\n\nLatte.update_tile_var\n\n\n\n\n\n\nNet\n\n\n#\n\n\nLatte.init_buffer\n \n \nMethod\n.\n\n\n\n\nInitialize a buffer in \nnet\n\n\n Params \n\n\n\n\nnet\n   \u2013 network to receive initialized buffer\n\n\nname\n  \u2013 name of the buffer\n\n\nshape\n \u2013 shape of the buffer\n\n\nfunc\n  \u2013 function used to initialize the buffer, should return an Array and              have a signature (Float32, dims...)\n\n\n\n\n#\n\n\nLatte.set_buffer\n \n \nMethod\n.\n\n\n\n\nAdd or update a buffer\n\n\n Params \n\n\n\n\nnet\n   \u2013 network to add/update buffer\n\n\nname\n  \u2013 name of the buffer\n\n\narr\n   \u2013 buffer\n\n\n_copy\n \u2013 whether to copy the buffer\n\n\n\n\n#\n\n\nLatte.set_buffer\n \n \nMethod\n.\n\n\n\n\nAdd or update a buffer at a particular time step \nt\n\n\n Params \n\n\n\n\nnet\n   \u2013 network to add/update buffer\n\n\nname\n  \u2013 name of the buffer\n\n\narr\n   \u2013 buffer\n\n\nt\n     \u2013 time step to add buffer\n\n\n\n\n#\n\n\nLatte.get_buffer\n \n \nMethod\n.\n\n\n\n\nGet a buffer associated with an ensemble\n\n\n Params \n\n\n\n\nnet\n   \u2013 network to get buffer\n\n\nens\n   \u2013 the ensemble\n\n\nname\n  \u2013 name of buffer associated with \nens\n\n\n\n\n#\n\n\nLatte.rand_values\n \n \nMethod\n.\n\n\n\n\nFill buffers with names containing \nrandval\n with random values\n\n\n#\n\n\nLatte.clear_values\n \n \nMethod\n.\n\n\n\n\nFill buffers with names containing \nvalue\n with zeros.\n\n\n#\n\n\nLatte.clear_\u2207\n \n \nMethod\n.\n\n\n\n\nFill buffers with names containing \n\u2207\n with zeros.\n\n\n\n\nConnections\n\n\n#\n\n\nLatte.check_one_to_one\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.check_dimensions_fixed\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n\n\nSynthesis and Optimization\n\n\n#\n\n\nLatte.add_send_exprs\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.add_recv_expr\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_forward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\nTODO: doc\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_forward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_forward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_backward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\nTODO: doc\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_backward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.init_backward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.add_forward_data_tasks\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.add_forward_julia_tasks\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.push_compute_tasks!\n \n \nMethod\n.\n\n\n\n\nTODO: doc FIXME: My, my this function is ugly, clean this up some day...\n\n\n#\n\n\nLatte.generate_c_function\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.gen_neuron_backward\n \n \nMethod\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.gen_neuron_forward\n \n \nMethod\n.\n\n\n\n\nnothing\n\n#\n\n\nLatte.gen_copy_block\n \n \nMethod\n.\n\n\n\n\nSynthesize a loopnest to copy value or \u2207 to the appropriate buffer\n\n\n#\n\n\nLatte.get_src_idx\n \n \nMethod\n.\n\n\n\n\nExtract the final expression of the mapping function to be used as an indexing expression.  Handles cases where the final expression can be a Tuple or a single value.\n\n\n Params \n\n\n\n\nmapping\n \u2013 an ast for a mapping function\n\n\n\n\n#\n\n\nLatte.optimize\n \n \nMethod\n.\n\n\n\n\nOptimize a function \nfn\n\n\n Params \n\n\n\n\nargs\n                \u2013 an ordered vector of arguments (buffers)\n\n\ntile_fusion_factors\n \u2013 factors for tile fusions determined by connection                            structure\n\n\nfn\n                  \u2013 the ast of the function to be optimized\n\n\n\n\n#\n\n\nLatte.unpack_tiled_loop\n \n \nFunction\n.\n\n\n\n\nConvert from an internal Latte tiled_loop to a normal Julia :for expression\n\n\n#\n\n\nLatte.is_tiled_loop\n \n \nFunction\n.\n\n\n\n\nCheck if \nnode\n is an internal Latte tiled_loop\n\n\n#\n\n\nLatte.get_tile_fusion_factor_forward\n \n \nFunction\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.get_tile_fusion_factor_backward\n \n \nFunction\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.update_tile_var\n \n \nFunction\n.\n\n\n\n\nReplace indexing expressions with \ntile_var\n with the proper tiled expression When \ninputs\n are not copied, the neuron transformer appends :NOTILE to the index expression to force Latte not to tile the expression.\n\n\n#\n\n\nLatte.inner_loop_tiler\n \n \nFunction\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.get_inner_loop_tiler\n \n \nFunction\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.tile_size_inliner\n \n \nFunction\n.\n\n\n\n\nTODO: doc\n\n\n#\n\n\nLatte.get_tile_loops\n \n \nFunction\n.\n\n\n\n\nTile loop variables use \n_tile_idx\n loopvars.\n\n\n\n\nUtility Datastructures\n\n\n#\n\n\nLatte.TaskSet\n \n \nType\n.\n\n\n\n\nA container for tasks for multiple \nPhase\ns\n\n\n Fields \n\n\n\n\ntasks \u2013 a dictionary containing a \nVector\n of tasks for each \nPhase\n\n\n\n\n#\n\n\nLatte.JuliaTask\n \n \nType\n.\n\n\n\n\nA task that calls \nfunc\n with \nargs...\n\n\n#\n\n\nLatte.UpdateTask\n \n \nType\n.\n\n\n\n\nA task that updates parameter \nparam_id\n\n\n#\n\n\nLatte.Batch\n \n \nType\n.\n\n\n\n\nUsed in neuron definitions to mark a field to be unique per batch item", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internals", 
            "text": "", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internals  Contents  Index  Net  Connections  Synthesis and Optimization  Utility Datastructures", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "Latte.Batch  Latte.JuliaTask  Latte.TaskSet  Latte.UpdateTask  Latte.add_forward_data_tasks  Latte.add_forward_julia_tasks  Latte.add_recv_expr  Latte.add_send_exprs  Latte.check_dimensions_fixed  Latte.check_one_to_one  Latte.clear_values  Latte.clear_\u2207  Latte.gen_copy_block  Latte.gen_neuron_backward  Latte.gen_neuron_forward  Latte.generate_c_function  Latte.get_buffer  Latte.get_inner_loop_tiler  Latte.get_src_idx  Latte.get_tile_fusion_factor_backward  Latte.get_tile_fusion_factor_forward  Latte.get_tile_loops  Latte.init_backward  Latte.init_backward  Latte.init_backward  Latte.init_buffer  Latte.init_forward  Latte.init_forward  Latte.init_forward  Latte.inner_loop_tiler  Latte.is_tiled_loop  Latte.optimize  Latte.push_compute_tasks!  Latte.rand_values  Latte.set_buffer  Latte.set_buffer  Latte.tile_size_inliner  Latte.unpack_tiled_loop  Latte.update_tile_var", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#net", 
            "text": "#  Latte.init_buffer     Method .   Initialize a buffer in  net   Params    net    \u2013 network to receive initialized buffer  name   \u2013 name of the buffer  shape  \u2013 shape of the buffer  func   \u2013 function used to initialize the buffer, should return an Array and              have a signature (Float32, dims...)   #  Latte.set_buffer     Method .   Add or update a buffer   Params    net    \u2013 network to add/update buffer  name   \u2013 name of the buffer  arr    \u2013 buffer  _copy  \u2013 whether to copy the buffer   #  Latte.set_buffer     Method .   Add or update a buffer at a particular time step  t   Params    net    \u2013 network to add/update buffer  name   \u2013 name of the buffer  arr    \u2013 buffer  t      \u2013 time step to add buffer   #  Latte.get_buffer     Method .   Get a buffer associated with an ensemble   Params    net    \u2013 network to get buffer  ens    \u2013 the ensemble  name   \u2013 name of buffer associated with  ens   #  Latte.rand_values     Method .   Fill buffers with names containing  randval  with random values  #  Latte.clear_values     Method .   Fill buffers with names containing  value  with zeros.  #  Latte.clear_\u2207     Method .   Fill buffers with names containing  \u2207  with zeros.", 
            "title": "Net"
        }, 
        {
            "location": "/lib/internals/#connections", 
            "text": "#  Latte.check_one_to_one     Method .   TODO: doc  #  Latte.check_dimensions_fixed     Method .   TODO: doc", 
            "title": "Connections"
        }, 
        {
            "location": "/lib/internals/#synthesis-and-optimization", 
            "text": "#  Latte.add_send_exprs     Method .   TODO: doc  #  Latte.add_recv_expr     Method .   TODO: doc  #  Latte.init_forward     Method .   TODO: doc  TODO: doc  TODO: doc  #  Latte.init_forward     Method .   TODO: doc  #  Latte.init_forward     Method .   TODO: doc  #  Latte.init_backward     Method .   TODO: doc  TODO: doc  TODO: doc  #  Latte.init_backward     Method .   TODO: doc  #  Latte.init_backward     Method .   TODO: doc  #  Latte.add_forward_data_tasks     Method .   TODO: doc  #  Latte.add_forward_julia_tasks     Method .   TODO: doc  #  Latte.push_compute_tasks!     Method .   TODO: doc FIXME: My, my this function is ugly, clean this up some day...  #  Latte.generate_c_function     Method .   TODO: doc  #  Latte.gen_neuron_backward     Method .   TODO: doc  #  Latte.gen_neuron_forward     Method .   nothing #  Latte.gen_copy_block     Method .   Synthesize a loopnest to copy value or \u2207 to the appropriate buffer  #  Latte.get_src_idx     Method .   Extract the final expression of the mapping function to be used as an indexing expression.  Handles cases where the final expression can be a Tuple or a single value.   Params    mapping  \u2013 an ast for a mapping function   #  Latte.optimize     Method .   Optimize a function  fn   Params    args                 \u2013 an ordered vector of arguments (buffers)  tile_fusion_factors  \u2013 factors for tile fusions determined by connection                            structure  fn                   \u2013 the ast of the function to be optimized   #  Latte.unpack_tiled_loop     Function .   Convert from an internal Latte tiled_loop to a normal Julia :for expression  #  Latte.is_tiled_loop     Function .   Check if  node  is an internal Latte tiled_loop  #  Latte.get_tile_fusion_factor_forward     Function .   TODO: doc  #  Latte.get_tile_fusion_factor_backward     Function .   TODO: doc  #  Latte.update_tile_var     Function .   Replace indexing expressions with  tile_var  with the proper tiled expression When  inputs  are not copied, the neuron transformer appends :NOTILE to the index expression to force Latte not to tile the expression.  #  Latte.inner_loop_tiler     Function .   TODO: doc  #  Latte.get_inner_loop_tiler     Function .   TODO: doc  #  Latte.tile_size_inliner     Function .   TODO: doc  #  Latte.get_tile_loops     Function .   Tile loop variables use  _tile_idx  loopvars.", 
            "title": "Synthesis and Optimization"
        }, 
        {
            "location": "/lib/internals/#utility-datastructures", 
            "text": "#  Latte.TaskSet     Type .   A container for tasks for multiple  Phase s   Fields    tasks \u2013 a dictionary containing a  Vector  of tasks for each  Phase   #  Latte.JuliaTask     Type .   A task that calls  func  with  args...  #  Latte.UpdateTask     Type .   A task that updates parameter  param_id  #  Latte.Batch     Type .   Used in neuron definitions to mark a field to be unique per batch item", 
            "title": "Utility Datastructures"
        }
    ]
}